---
/* LAYOUT GUARDRAIL: Content width must not be modified for sidebar. TOC/Rail belong in aside (right column). */
import type { MarkdownHeading } from 'astro'
import Layout from '~/layouts/Layout.astro'
import DividerText from '~/components/DividerText.astro'
import PostAddendum from '~/components/PostAddendum.astro'
import PostInfo from '~/components/PostInfo.astro'
import PostPreview from '~/components/PostPreview.astro'
import TableOfContents from '~/components/TableOfContents.astro'
import Tags from '~/components/Tags.astro'
import ArticleRail from '~/components/ArticleRail.astro'
import DataState from '~/components/DataState.astro'
import ErrorState from '~/components/ErrorState.astro'
import siteConfig from '~/site.config'
import { getPublicArticleByAuthorSlug, getPublicArticleById, listPublicArticles } from '~/lib/publicApi'
import GiscusLoader from '~/components/GiscusLoader.astro'
import {
  DEFAULT_RECOMMENDATION_COUNT,
  normalizeRecommendationCount,
} from '~/lib/config'

export const prerender = false

const author = String(Astro.params.author ?? '').trim()
const slug = String(Astro.params.slug ?? '').trim()
const articleIdParam = String(Astro.url.searchParams.get('id') ?? '').trim()
if (!author || !slug) throw new Response('Not Found', { status: 404 })

const resolveErrorStatus = (err: unknown): number => {
  if (err instanceof Error && err.message.startsWith('HTTP_')) {
    const numeric = Number.parseInt(err.message.replace('HTTP_', ''), 10)
    if (Number.isFinite(numeric)) return numeric
  }
  if (typeof err === 'object' && err !== null && 'status' in err) {
    const status = (err as { status?: number }).status
    if (typeof status === 'number') return status
  }
  return 502
}

const ABSOLUTE_SRC_PATTERN = /^(?:[a-z][a-z0-9+.-]*:|\/\/|\/)/i
const normalizeRelativeImageSources = (html: string): string =>
  html.replace(/(<img\b[^>]*?\bsrc\s*=\s*)(['"])([^'"]+)\2/gi, (match, prefix, quote, srcValue) => {
    if (ABSOLUTE_SRC_PATTERN.test(srcValue)) return match
    try {
      const normalized = new URL(srcValue, 'http://example.com/').pathname
      return `${prefix}${quote}${normalized}${quote}`
    } catch {
      const fallback = srcValue.replace(/^\.+/, '').replace(/^\/+/, '')
      return `${prefix}${quote}/${fallback}${quote}`
    }
  })

const fetchArticleBySlug = () => getPublicArticleByAuthorSlug({ authorUsername: author, slug })

let article: Awaited<ReturnType<typeof getPublicArticleById>> | null = null
let articleError: string | null = null
try {
  article = articleIdParam ? await getPublicArticleById(articleIdParam) : await fetchArticleBySlug()
} catch (err) {
  if (articleIdParam) {
    try {
      article = await fetchArticleBySlug()
    } catch (slugErr) {
      const status = resolveErrorStatus(slugErr)
      if (status === 404) throw new Response('Not Found', { status: 404 })
      articleError = slugErr instanceof Error ? slugErr.message : 'Failed to load article from server API'
    }
  } else {
    const status = resolveErrorStatus(err)
    if (status === 404) throw new Response('Not Found', { status: 404 })
    articleError = err instanceof Error ? err.message : 'Failed to load article from server API'
  }
}
const tocHeadings = article
  ? ((article.content.toc ?? []).map((item) => ({
      depth: item.level,
      slug: item.id,
      text: item.text,
    })) as MarkdownHeading[])
  : ([] as MarkdownHeading[])

const enableRecommendations = Boolean(article) && siteConfig.enableRecommendations !== false
const enableAuthorCard = siteConfig.enableAuthorCard !== false
const enableFooterAuthorCard = siteConfig.enableFooterAuthorCard ?? enableAuthorCard
const recommendationMode = siteConfig.recommendationMode ?? 'tag'
const recommendationCount = normalizeRecommendationCount(
  siteConfig.recommendationCount,
  DEFAULT_RECOMMENDATION_COUNT,
)
const recommendationFetchSize = Math.max(1, Math.min(100, recommendationCount + 8))

const tagCandidate = article ? article.tagDetails?.[0] ?? null : null
const tagSlug = tagCandidate?.slug ?? null
const tagName = tagCandidate?.name ?? null

let morePostsTitle = 'More Posts'
let morePosts = [] as Awaited<ReturnType<typeof listPublicArticles>>['items']

const seenPostIds = new Set<string>(article?.id ? [article.id] : [])
const addUniquePosts = (items: Awaited<ReturnType<typeof listPublicArticles>>['items']) => {
  for (const item of items) {
    if (!item?.id) continue
    if (seenPostIds.has(item.id)) continue
    seenPostIds.add(item.id)
    morePosts.push(item)
    if (morePosts.length >= recommendationCount) break
  }
}

const tryAppend = async (
  input: Parameters<typeof listPublicArticles>[0],
  title: string,
) => {
  try {
    const result = await listPublicArticles(input)
    const before = morePosts.length
    addUniquePosts(result.items)
    if (before === 0 && morePosts.length > 0) {
      morePostsTitle = title
    }
  } catch {
    // ignore
  }
}

if (article && enableRecommendations && recommendationCount > 0) {
  if (recommendationMode === 'category' && article.categoryId) {
    await tryAppend(
      { page: 1, pageSize: recommendationFetchSize, categoryId: article.categoryId },
      article.category?.name ? `${article.category.name} Category` : 'More Posts',
    )
  } else if (recommendationMode === 'tag' && tagSlug) {
    await tryAppend(
      { page: 1, pageSize: recommendationFetchSize, tag: tagSlug },
      tagName ? `Tag: ${tagName}` : 'More Posts',
    )
  } else if (recommendationMode === 'random') {
    await tryAppend(
      { page: 1, pageSize: recommendationFetchSize, sort: 'random' },
      'Random Posts',
    )
  } else {
    await tryAppend({ page: 1, pageSize: recommendationFetchSize }, 'Latest Posts')
  }

  // Fallback chain to avoid empty/sparse recommendation lists
  if (morePosts.length < recommendationCount && recommendationMode !== 'category' && article.categoryId) {
    await tryAppend(
      { page: 1, pageSize: recommendationFetchSize, categoryId: article.categoryId },
      article.category?.name ? `${article.category.name} Category` : morePostsTitle,
    )
  }
  if (morePosts.length < recommendationCount && recommendationMode !== 'tag' && tagSlug) {
    await tryAppend(
      { page: 1, pageSize: recommendationFetchSize, tag: tagSlug },
      tagName ? `Tag: ${tagName}` : morePostsTitle,
    )
  }
  if (morePosts.length < recommendationCount && recommendationMode !== 'date') {
    await tryAppend({ page: 1, pageSize: recommendationFetchSize }, 'Latest Posts')
  }

  morePosts = morePosts.slice(0, recommendationCount)
}

const articleHtml = article ? normalizeRelativeImageSources(article.content.html ?? '') : ''
---

<Layout
  title={article?.title ?? 'Post'}
  description={article?.summary ?? undefined}
  author={article?.author?.username ?? undefined}
  tags={article?.tagDetails?.map((t) => t.name) ?? []}
>
  {
    !article ? (
      <section class="mt-6 md:mx-2">
        <DataState title="Failed to load post" description="Please check your connection and try again.">
          <ErrorState
            message={articleError ?? 'Failed to load this post.'}
            retryHref={`${Astro.url.pathname}${Astro.url.search}`}
            retryText="Try again"
            secondaryHref="/posts"
            secondaryText="Back to archive"
          />
        </DataState>
      </section>
    ) : (
      <>
        {/* 右侧固定侧边栏 - ArticleRail (始终固定在右下角) */}
        <div class="fixed-sidebar rail-sidebar hidden xl:block">
          <ArticleRail
            articleId={article.id}
            authorId={article.authorId}
            initialLikesCount={article.likesCount}
          />
        </div>
        
        <article class="py-7.5" data-pagefind-body data-article-body>
          {
            article.coverImageUrl && (
              <img
                src={article.coverImageUrl}
                alt={article.title}
                loading="lazy"
                class="w-full rounded-xl mb-5"
              />
            )
          }
          <div class="md:mx-2">
            <h1 id={article.slug} class="mb-4 text-[1.75rem] text-heading1 font-semibold">
              # {article.title}
            </h1>
            <div class="my-2 border-l-2 border-accent/80 pl-4 py-2">
              <PostInfo article={article} class="mb-1" />
              {article.tagDetails.length > 0 && (
                <div class="mt-4">
                  <Tags tags={article.tagDetails} />
                </div>
              )}
            </div>
          </div>

          {/* 正文内容区域 - TOC 从这里开始 */}
          <div class="relative">
            {/* 右侧 Sticky 侧边栏 - TOC (与正文第一个标题平齐) */}
            {tocHeadings.length > 0 && (
              <aside class="article-sidebar hidden xl:block">
                <div class="sidebar-sticky-wrapper">
                  <TableOfContents headings={tocHeadings} />
                </div>
              </aside>
            )}
            
            <div class="mb-5 prose min-w-0" set:html={articleHtml} />
          </div>
        </article>
      </>
    )
  }

  {
    article && morePosts.length > 0 && (
      <section>
        <DividerText text={morePostsTitle} />
        {morePosts.map((item) => (
          <PostPreview article={item} />
        ))}
      </section>
    )
  }

  {article && enableFooterAuthorCard && <PostAddendum author={article.author} />}

  {
    article && siteConfig.giscus && (
      <section>
        <DividerText text="Comments" />
        <GiscusLoader />
      </section>
    )
  }

  <script is:inline>
    (() => {
      const handleBrokenImages = () => {
        const container = document.querySelector('[data-article-body]')
        if (!container) return
        container.querySelectorAll('img').forEach((img) => {
          if (img.dataset.invalidHandled) return
          img.addEventListener('error', () => {
            if (img.dataset.invalidHandled) return
            img.dataset.invalidHandled = '1'
            const altText = (img.getAttribute('alt') ?? '').trim() || '无效图片资源'
            const fallback = document.createElement('div')
            fallback.className = 'article-image-alt'
            fallback.textContent = altText
            img.replaceWith(fallback)
          })
        })
      }

      if (document.readyState === 'loading') {
        window.addEventListener('DOMContentLoaded', handleBrokenImages)
      } else {
        handleBrokenImages()
      }
    })()
  </script>

  <style is:inline>
    /* ArticleRail 固定侧边栏 - 始终固定在右下角 */
    .fixed-sidebar {
      position: fixed;
      z-index: 40;
      width: 14rem; /* w-56 */
    }
    
    .rail-sidebar {
      bottom: 2.5rem; /* 距离底部 2.5rem */
      /* 计算位置：50% + (max-w-3xl 的一半 24rem) + 间隔 1.5rem */
      left: calc(50% + 24rem + 1.5rem);
    }
    
    /* TOC 侧边栏 - 与正文第一个标题平齐，滚动后 sticky 固定 */
    .article-sidebar {
      position: absolute;
      right: -17.5rem; /* 正文外部，考虑宽度 14rem + 间隔 3.5rem，与 Rail 左对齐 */
      top: 0; /* 与 prose 内容起始位置对齐 */
      width: 14rem;
      height: 100%;
      z-index: 40;
      pointer-events: none; /* 让点击穿透到下方内容 */
    }
    
    .article-sidebar > * {
      pointer-events: auto; /* 恢复内部元素的点击 */
    }
    
    .sidebar-sticky-wrapper {
      position: sticky;
      top: 5rem; /* 滚动到距离顶部 5rem 时固定 */
    }
    
    /* 当屏幕不够大时隐藏 (xl breakpoint: 1280px) */
    @media (max-width: 1279px) {
      .fixed-sidebar,
      .article-sidebar {
        display: none !important;
      }
    }
  </style>

</Layout>
