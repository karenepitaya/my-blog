---
import type { MarkdownHeading } from 'astro'
import Layout from '~/layouts/Layout.astro'
import DividerText from '~/components/DividerText.astro'
import PostAddendum from '~/components/PostAddendum.astro'
import PostInfo from '~/components/PostInfo.astro'
import PostPreview from '~/components/PostPreview.astro'
import ScrollUpButton from '~/components/ScrollUpButton.astro'
import TableOfContents from '~/components/TableOfContents.astro'
import Tags from '~/components/Tags.astro'
import DataState from '~/components/DataState.astro'
import ErrorState from '~/components/ErrorState.astro'
import siteConfig from '~/site.config'
import { getPublicArticleByAuthorSlug, getPublicArticleById, listPublicArticles } from '~/lib/publicApi'
import GiscusLoader from '~/components/GiscusLoader.astro'
import {
  DEFAULT_RECOMMENDATION_COUNT,
  normalizeRecommendationCount,
} from '~/lib/config'

export const prerender = false

const author = String(Astro.params.author ?? '').trim()
const slug = String(Astro.params.slug ?? '').trim()
const articleIdParam = String(Astro.url.searchParams.get('id') ?? '').trim()
if (!author || !slug) throw new Response('Not Found', { status: 404 })

const resolveErrorStatus = (err: unknown): number => {
  if (err instanceof Error && err.message.startsWith('HTTP_')) {
    const numeric = Number.parseInt(err.message.replace('HTTP_', ''), 10)
    if (Number.isFinite(numeric)) return numeric
  }
  if (typeof err === 'object' && err !== null && 'status' in err) {
    const status = (err as { status?: number }).status
    if (typeof status === 'number') return status
  }
  return 502
}

const ABSOLUTE_SRC_PATTERN = /^(?:[a-z][a-z0-9+.-]*:|\/\/|\/)/i
const normalizeRelativeImageSources = (html: string): string =>
  html.replace(/(<img\b[^>]*?\bsrc\s*=\s*)(['"])([^'"]+)\2/gi, (match, prefix, quote, srcValue) => {
    if (ABSOLUTE_SRC_PATTERN.test(srcValue)) return match
    try {
      const normalized = new URL(srcValue, 'http://example.com/').pathname
      return `${prefix}${quote}${normalized}${quote}`
    } catch {
      const fallback = srcValue.replace(/^\.+/, '').replace(/^\/+/, '')
      return `${prefix}${quote}/${fallback}${quote}`
    }
  })

const fetchArticleBySlug = () => getPublicArticleByAuthorSlug({ authorUsername: author, slug })

let article: Awaited<ReturnType<typeof getPublicArticleById>> | null = null
let articleError: string | null = null
try {
  article = articleIdParam ? await getPublicArticleById(articleIdParam) : await fetchArticleBySlug()
} catch (err) {
  if (articleIdParam) {
    try {
      article = await fetchArticleBySlug()
    } catch (slugErr) {
      const status = resolveErrorStatus(slugErr)
      if (status === 404) throw new Response('Not Found', { status: 404 })
      articleError = slugErr instanceof Error ? slugErr.message : 'Failed to load article from server API'
    }
  } else {
    const status = resolveErrorStatus(err)
    if (status === 404) throw new Response('Not Found', { status: 404 })
    articleError = err instanceof Error ? err.message : 'Failed to load article from server API'
  }
}
const tocHeadings = article
  ? ((article.content.toc ?? []).map((item) => ({
      depth: item.level,
      slug: item.id,
      text: item.text,
    })) as MarkdownHeading[])
  : ([] as MarkdownHeading[])

const enableRecommendations = Boolean(article) && siteConfig.enableRecommendations !== false
const enableAuthorCard = siteConfig.enableAuthorCard !== false
const enableFooterAuthorCard = siteConfig.enableFooterAuthorCard ?? enableAuthorCard
const recommendationMode = siteConfig.recommendationMode ?? 'tag'
const recommendationCount = normalizeRecommendationCount(
  siteConfig.recommendationCount,
  DEFAULT_RECOMMENDATION_COUNT,
)
const recommendationFetchSize = Math.max(1, Math.min(100, recommendationCount + 8))

const tagCandidate = article ? article.tagDetails?.[0] ?? null : null
const tagSlug = tagCandidate?.slug ?? null
const tagName = tagCandidate?.name ?? null

let morePostsTitle = 'More Posts'
let morePosts = [] as Awaited<ReturnType<typeof listPublicArticles>>['items']

const seenPostIds = new Set<string>(article?.id ? [article.id] : [])
const addUniquePosts = (items: Awaited<ReturnType<typeof listPublicArticles>>['items']) => {
  for (const item of items) {
    if (!item?.id) continue
    if (seenPostIds.has(item.id)) continue
    seenPostIds.add(item.id)
    morePosts.push(item)
    if (morePosts.length >= recommendationCount) break
  }
}

const tryAppend = async (
  input: Parameters<typeof listPublicArticles>[0],
  title: string,
) => {
  try {
    const result = await listPublicArticles(input)
    const before = morePosts.length
    addUniquePosts(result.items)
    if (before === 0 && morePosts.length > 0) {
      morePostsTitle = title
    }
  } catch {
    // ignore
  }
}

if (article && enableRecommendations && recommendationCount > 0) {
  if (recommendationMode === 'category' && article.categoryId) {
    await tryAppend(
      { page: 1, pageSize: recommendationFetchSize, categoryId: article.categoryId },
      article.category?.name ? `${article.category.name} Category` : 'More Posts',
    )
  } else if (recommendationMode === 'tag' && tagSlug) {
    await tryAppend(
      { page: 1, pageSize: recommendationFetchSize, tag: tagSlug },
      tagName ? `Tag: ${tagName}` : 'More Posts',
    )
  } else if (recommendationMode === 'random') {
    await tryAppend(
      { page: 1, pageSize: recommendationFetchSize, sort: 'random' },
      'Random Posts',
    )
  } else {
    await tryAppend({ page: 1, pageSize: recommendationFetchSize }, 'Latest Posts')
  }

  // Fallback chain to avoid empty/sparse recommendation lists
  if (morePosts.length < recommendationCount && recommendationMode !== 'category' && article.categoryId) {
    await tryAppend(
      { page: 1, pageSize: recommendationFetchSize, categoryId: article.categoryId },
      article.category?.name ? `${article.category.name} Category` : morePostsTitle,
    )
  }
  if (morePosts.length < recommendationCount && recommendationMode !== 'tag' && tagSlug) {
    await tryAppend(
      { page: 1, pageSize: recommendationFetchSize, tag: tagSlug },
      tagName ? `Tag: ${tagName}` : morePostsTitle,
    )
  }
  if (morePosts.length < recommendationCount && recommendationMode !== 'date') {
    await tryAppend({ page: 1, pageSize: recommendationFetchSize }, 'Latest Posts')
  }

  morePosts = morePosts.slice(0, recommendationCount)
}

const articleHtml = article ? normalizeRelativeImageSources(article.content.html ?? '') : ''
---

<Layout
  title={article?.title ?? 'Post'}
  description={article?.summary ?? undefined}
  author={article?.author?.username ?? undefined}
  tags={article?.tagDetails?.map((t) => t.name) ?? []}
>
  {
    !article ? (
      <section class="mt-6 md:mx-2">
        <DataState title="Failed to load post" description="Please check your connection and try again.">
          <ErrorState
            message={articleError ?? 'Failed to load this post.'}
            retryHref={`${Astro.url.pathname}${Astro.url.search}`}
            retryText="Try again"
            secondaryHref="/posts"
            secondaryText="Back to archive"
          />
        </DataState>
      </section>
    ) : (
      <article class="max-w-full py-7.5" data-pagefind-body data-article-body>
    {
      article.coverImageUrl && (
        <img
          src={article.coverImageUrl}
          alt={article.title}
          loading="lazy"
          class="w-full rounded-xl mb-5"
        />
      )
    }
    <div class="md:mx-2">
      <h1 id={article.slug} class="mb-4 text-[1.75rem] text-heading1 font-semibold">
        # {article.title}
      </h1>
      <div class="my-2 border-l-2 border-accent/80 pl-4 py-2">
        <PostInfo article={article} class="mb-1" />
        {article.tagDetails.length > 0 && (
          <div class="mt-4">
            <Tags tags={article.tagDetails} />
          </div>
        )}
      </div>
    </div>

    <div class="flex flex-col xl:gap-1 2xl:gap-18 xl:flex-row xl:items-start">
      {tocHeadings.length > 0 && <TableOfContents headings={tocHeadings} />}
      <div class="mb-5 xl:min-w-full 2xl:min-w-full prose" set:html={articleHtml} />
    </div>
  </article>
    )
  }

  {
    article && morePosts.length > 0 && (
      <section>
        <DividerText text={morePostsTitle} />
        {morePosts.map((item) => (
          <PostPreview article={item} />
        ))}
      </section>
    )
  }

  {article && enableFooterAuthorCard && <PostAddendum author={article.author} />}

  {
    article && siteConfig.giscus && (
      <section>
        <DividerText text="Comments" />
        <GiscusLoader />
      </section>
    )
  }

  <script is:inline>
    (() => {
      const handleBrokenImages = () => {
        const container = document.querySelector('[data-article-body]')
        if (!container) return
        container.querySelectorAll('img').forEach((img) => {
          if (img.dataset.invalidHandled) return
          img.addEventListener('error', () => {
            if (img.dataset.invalidHandled) return
            img.dataset.invalidHandled = '1'
            const altText = (img.getAttribute('alt') ?? '').trim() || '无效图片资源'
            const fallback = document.createElement('div')
            fallback.className = 'article-image-alt'
            fallback.textContent = altText
            img.replaceWith(fallback)
          })
        })
      }

      if (document.readyState === 'loading') {
        window.addEventListener('DOMContentLoaded', handleBrokenImages)
      } else {
        handleBrokenImages()
      }
    })()
  </script>

  <ScrollUpButton />
</Layout>
