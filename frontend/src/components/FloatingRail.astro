---
import IconHeart from '~/icons/heart.svg'
import IconChevronUp from '~/icons/chevron-up.svg'

interface Props {
  articleId: string
  authorId?: string
  initialLikesCount?: number
}

const articleId = String(Astro.props.articleId ?? '').trim()
if (!articleId) throw new Error('FloatingRail: articleId is required')

const authorId = typeof Astro.props.authorId === 'string' ? Astro.props.authorId.trim() : ''
const initialLikesCount = Math.max(0, Number(Astro.props.initialLikesCount ?? 0) || 0)

const apiBaseRaw = import.meta.env.PUBLIC_API_BASE_URL
const apiBase = (apiBaseRaw?.trim() ? apiBaseRaw.trim() : 'http://localhost:3000/api').replace(/\/$/, '')
---

<div
  class="fixed z-50 flex flex-col gap-2 opacity-55 transition-opacity duration-150 ease-out hover:opacity-100 focus-within:opacity-100 motion-reduce:transition-none"
  style="right: 1rem; top: 35vh;"
  data-floating-rail
  data-article-id={articleId}
  data-author-id={authorId}
  data-api-base={apiBase}
  data-initial-count={String(initialLikesCount)}
  aria-label="Article actions"
>
  <button
    type="button"
    class="group inline-flex items-center justify-center rounded-2xl border border-foreground/10 bg-foreground/6 p-2.5 text-foreground/80 shadow-lg shadow-accent/5 backdrop-blur transition-colors hover:bg-foreground/8 hover:border-accent/30 hover:text-heading1 active:scale-95 disabled:opacity-45 disabled:cursor-not-allowed motion-reduce:transform-none"
    data-like-btn
    aria-label="Like this article"
    aria-pressed="false"
    disabled
  >
    <span class="grid place-items-center rounded-xl bg-foreground/6 border border-foreground/10 size-10">
      <IconHeart class="size-5 text-foreground/70 group-hover:text-accent transition-colors" aria-hidden="true" />
    </span>
    <span class="sr-only">Likes</span>
    <span class="ml-2 font-mono tabular-nums text-heading1" data-like-count>{initialLikesCount}</span>
  </button>

  <button
    type="button"
    class="group inline-flex items-center justify-center rounded-2xl border border-foreground/10 bg-foreground/6 p-2.5 text-foreground/80 shadow-lg shadow-accent/5 backdrop-blur transition-colors hover:bg-foreground/8 hover:border-accent/30 hover:text-heading1 active:scale-95 disabled:opacity-35 disabled:cursor-not-allowed motion-reduce:transform-none"
    data-top-btn
    aria-label="Back to top"
  >
    <span class="grid place-items-center rounded-xl bg-foreground/6 border border-foreground/10 size-10">
      <IconChevronUp class="size-5 text-foreground/70 group-hover:text-accent transition-colors" aria-hidden="true" />
    </span>
  </button>

  <div
    class="max-w-56 rounded-xl border border-foreground/10 bg-background/85 px-3 py-2 text-xs text-foreground/70 shadow-lg shadow-accent/5 backdrop-blur hidden"
    data-rail-toast
    role="status"
    aria-live="polite"
  />
</div>

<script is:inline>
  (() => {
    const roots = document.querySelectorAll('[data-floating-rail]')
    if (!roots.length) return

    const CACHE_TTL_MS = 15_000
    const cacheKey = '__articleLikesCache'
    const inflightKey = '__articleLikesInflight'

    const getCache = () => {
      // @ts-ignore
      const existing = window[cacheKey]
      if (existing instanceof Map) return existing
      const created = new Map()
      // @ts-ignore
      window[cacheKey] = created
      return created
    }

    const getInflight = () => {
      // @ts-ignore
      const existing = window[inflightKey]
      if (existing instanceof Map) return existing
      const created = new Map()
      // @ts-ignore
      window[inflightKey] = created
      return created
    }

    const clamp0 = (n) => (Number.isFinite(n) ? Math.max(0, n) : 0)

    const prefersReducedMotion = () =>
      typeof window !== 'undefined' &&
      typeof window.matchMedia === 'function' &&
      window.matchMedia('(prefers-reduced-motion: reduce)').matches

    const createApi = (apiBase) => {
      const base = String(apiBase || '').replace(/\/$/, '')
      const buildUrl = (articleId) => `${base}/public/articles/${encodeURIComponent(articleId)}/likes`

      const request = async (articleId, method) => {
        const res = await fetch(buildUrl(articleId), {
          method,
          headers: { Accept: 'application/json' },
        })

        if (!res.ok) throw new Error(`HTTP_${res.status}`)
        const json = await res.json()
        if (!json || json.success !== true) throw new Error('API_ERROR')
        return json.data
      }

      return {
        get: (articleId) => request(articleId, 'GET'),
        like: (articleId) => request(articleId, 'POST'),
        unlike: (articleId) => request(articleId, 'DELETE'),
      }
    }

    const showToast = (root, message) => {
      const el = root.querySelector('[data-rail-toast]')
      if (!el) return
      el.textContent = String(message || '')
      el.classList.remove('hidden')
      window.clearTimeout(el.__hideTimer)
      el.__hideTimer = window.setTimeout(() => {
        el.classList.add('hidden')
      }, 2_500)
    }

    const positionRail = (root) => {
      const prose = document.querySelector('article div.prose') || document.querySelector('[data-article-body] div.prose')
      if (!prose) return

      const vw = window.innerWidth
      const vh = window.innerHeight

      // Mobile fallback: keep it in the bottom-right corner to avoid overlaying content.
      if (vw < 1024) {
        root.style.right = '1rem'
        root.style.bottom = '1.25rem'
        root.style.top = 'auto'
        root.style.left = 'auto'
        return
      }

      root.style.bottom = 'auto'
      root.style.right = 'auto'

      const proseRect = prose.getBoundingClientRect()
      const railRect = root.getBoundingClientRect()
      const railW = Math.max(48, Math.round(railRect.width || 56))

      const gap = 14
      const safe = 14

      const spaceRight = vw - proseRect.right
      const spaceLeft = proseRect.left

      let leftPx = proseRect.right + gap
      if (spaceRight < railW + gap && spaceLeft >= railW + gap) {
        leftPx = proseRect.left - railW - gap
      }

      leftPx = Math.min(Math.max(safe, leftPx), Math.max(safe, vw - railW - safe))
      root.style.left = `${Math.round(leftPx)}px`
      root.style.top = `${Math.round(Math.max(96, vh * 0.32))}px`
    }

    const init = (root) => {
      const articleId = root.dataset.articleId || ''
      const authorId = root.dataset.authorId || ''
      const apiBase = root.dataset.apiBase || ''
      if (!articleId || !apiBase) return

      const api = createApi(apiBase)
      const likeBtn = root.querySelector('[data-like-btn]')
      const topBtn = root.querySelector('[data-top-btn]')
      const countEl = root.querySelector('[data-like-count]')
      const likeIcon = likeBtn ? likeBtn.querySelector('svg') : null
      if (!likeBtn || !topBtn || !countEl) return

      const cache = getCache()
      const inflight = getInflight()

      const state = {
        ready: false,
        pending: false,
        liked: false,
        likesCount: clamp0(Number(root.dataset.initialCount || '0')),
        stableLiked: false,
        stableCount: clamp0(Number(root.dataset.initialCount || '0')),
        queuedIntent: null,
      }

      const renderLike = () => {
        countEl.textContent = String(state.likesCount)
        likeBtn.setAttribute('aria-pressed', state.liked ? 'true' : 'false')
        likeBtn.setAttribute('aria-label', state.liked ? 'Unlike this article' : 'Like this article')

        likeBtn.classList.toggle('bg-red/10', state.liked)
        likeBtn.classList.toggle('border-red/30', state.liked)
        likeBtn.classList.toggle('hover:border-red/40', state.liked)

        if (likeIcon) {
          likeIcon.classList.toggle('text-red', state.liked)
          likeIcon.classList.toggle('text-foreground/70', !state.liked)
        }

        likeBtn.disabled = !state.ready || state.pending
        likeBtn.setAttribute('aria-busy', state.pending ? 'true' : 'false')
      }

      const dispatchAuthorDelta = (delta) => {
        if (!authorId || !delta) return
        window.dispatchEvent(
          new CustomEvent('article:likes-delta', {
            detail: { articleId, authorId, delta, liked: state.liked, likesCount: state.likesCount },
          })
        )
      }

      const setFromServer = (data, options) => {
        const prevLiked = state.stableLiked
        const nextLiked = Boolean(data && data.liked)
        const delta = (nextLiked ? 1 : 0) - (prevLiked ? 1 : 0)

        state.ready = true
        state.pending = false
        state.liked = nextLiked
        state.likesCount = clamp0(Number(data && data.likesCount))
        state.stableLiked = state.liked
        state.stableCount = state.likesCount
        cache.set(articleId, { at: Date.now(), data: { likesCount: state.likesCount, liked: state.liked } })
        renderLike()

        if (options && options.mutation) dispatchAuthorDelta(delta)
      }

      const revertToStable = () => {
        state.liked = state.stableLiked
        state.likesCount = state.stableCount
        renderLike()
      }

      const optimisticApply = (nextLiked) => {
        const next = Boolean(nextLiked)
        if (next === state.liked) return
        state.liked = next
        state.likesCount = clamp0(state.likesCount + (next ? 1 : -1))
        renderLike()
      }

      const sendIntent = async (nextLiked) => {
        const desired = Boolean(nextLiked)
        const op = desired ? 'like' : 'unlike'
        const inflightId = `${articleId}:${op}`
        if (inflight.has(inflightId)) return inflight.get(inflightId)

        const p = (async () => {
          try {
            state.pending = true
            renderLike()

            const data = desired ? await api.like(articleId) : await api.unlike(articleId)
            setFromServer(data, { mutation: true })

            if (state.queuedIntent !== null && state.queuedIntent !== state.liked) {
              const queued = state.queuedIntent
              state.queuedIntent = null
              return await sendIntent(queued)
            }

            return data
          } catch (err) {
            state.pending = false
            state.ready = true
            state.queuedIntent = null
            revertToStable()
            showToast(root, '网络异常：已回滚（可重试）')
            throw err
          } finally {
            inflight.delete(inflightId)
          }
        })()

        inflight.set(inflightId, p)
        return p
      }

      const refreshLike = async () => {
        const cached = cache.get(articleId)
        const now = Date.now()
        if (cached && now - cached.at < CACHE_TTL_MS) {
          setFromServer(cached.data, { mutation: false })
          return
        }

        try {
          const data = await api.get(articleId)
          setFromServer(data, { mutation: false })
        } catch {
          state.ready = true
          state.pending = false
          renderLike()
          showToast(root, '点赞状态加载失败（稍后可重试）')
        }
      }

      likeBtn.addEventListener('click', () => {
        const desired = !state.liked
        optimisticApply(desired)

        if (state.pending) {
          state.queuedIntent = desired
          return
        }

        void sendIntent(desired)
      })

      // ToTop: disabled/weak at top, enabled after leaving the top region.
      const topHeading = document.querySelector('h1')
      const topOffset = topHeading ? topHeading.offsetTop : 0

      const setTopDisabled = (disabled) => {
        topBtn.disabled = Boolean(disabled)
      }

      topBtn.addEventListener('click', () => {
        if (topBtn.disabled) return
        const behavior = prefersReducedMotion() ? 'auto' : 'smooth'
        window.scrollTo({ top: topOffset, behavior })
      })

      if (topHeading) {
        const obs = new IntersectionObserver(
          (entries) => {
            const entry = entries[0]
            setTopDisabled(Boolean(entry && entry.isIntersecting))
          },
          { rootMargin: `0px 0px -95% 0px` }
        )
        obs.observe(topHeading)
      } else {
        setTopDisabled(false)
      }

      positionRail(root)
      window.addEventListener('resize', () => positionRail(root))
      void refreshLike()
    }

    roots.forEach((root) => init(root))
  })()
</script>

